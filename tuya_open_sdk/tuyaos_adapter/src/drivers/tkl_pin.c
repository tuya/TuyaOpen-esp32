/**
 * @file tkl_pin.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */
#include "freertos/FreeRTOS.h"
#include "esp_err.h"
#include "esp_log.h"
#include "driver/gpio.h"
#include "hal/gpio_types.h"

#include "tuya_error_code.h"
#include "tuya_cloud_types.h"
#include "tkl_system.h"
#include "tkl_memory.h"
#include "tkl_gpio.h"

#define DBG_TAG "TKL_PIN"

#define PIN_DEV_CHECK_ERROR_RETURN(__PIN, __ERROR)                          \
    if (__PIN >= sizeof(pinmap)/sizeof(pinmap[0])) {                        \
        return __ERROR;                                                     \
    }

typedef void (*tuya_pin_irq_cb)(void *args);

typedef struct {
    int gpio;
    tuya_pin_irq_cb cb;
    void *args;
} pin_dev_map_t;

static pin_dev_map_t pinmap[] = {
    {GPIO_NUM_0,  NULL, NULL}, {GPIO_NUM_1,  NULL, NULL}, {GPIO_NUM_2,  NULL, NULL}, {GPIO_NUM_3,  NULL, NULL}, 
    {GPIO_NUM_4,  NULL, NULL}, {GPIO_NUM_5,  NULL, NULL}, {GPIO_NUM_6,  NULL, NULL}, {GPIO_NUM_7,  NULL, NULL}, 
    {GPIO_NUM_8,  NULL, NULL}, {GPIO_NUM_9,  NULL, NULL}, {GPIO_NUM_10, NULL, NULL}, {GPIO_NUM_11, NULL, NULL}, 
    {GPIO_NUM_12, NULL, NULL}, {GPIO_NUM_13, NULL, NULL}, {GPIO_NUM_14, NULL, NULL}, {GPIO_NUM_15, NULL, NULL}, 
    {GPIO_NUM_16, NULL, NULL}, {GPIO_NUM_17, NULL, NULL}, {GPIO_NUM_18, NULL, NULL}, {GPIO_NUM_19, NULL, NULL}, 
    {GPIO_NUM_20, NULL, NULL}, 
    
    #if defined(CONFIG_IDF_TARGET_ESP32C3)
    {GPIO_NUM_21, NULL, NULL},
    #elif defined(CONFIG_IDF_TARGET_ESP32C6)
    {GPIO_NUM_21, NULL, NULL}, {GPIO_NUM_22, NULL, NULL}, {GPIO_NUM_23, NULL, NULL}, {GPIO_NUM_24, NULL, NULL},
    {GPIO_NUM_25, NULL, NULL}, {GPIO_NUM_26, NULL, NULL}, {GPIO_NUM_27, NULL, NULL}, {GPIO_NUM_28, NULL, NULL},
    {GPIO_NUM_29, NULL, NULL}, {GPIO_NUM_30, NULL, NULL},
    #elif defined(CONFIG_IDF_TARGET_ESP32)
    {GPIO_NUM_21, NULL, NULL}, {GPIO_NUM_22, NULL, NULL}, {GPIO_NUM_23, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL},
    {GPIO_NUM_25, NULL, NULL}, {GPIO_NUM_26, NULL, NULL}, {GPIO_NUM_27, NULL, NULL}, {GPIO_NUM_28, NULL, NULL},
    {GPIO_NUM_29, NULL, NULL}, {GPIO_NUM_30, NULL, NULL}, {GPIO_NUM_31, NULL, NULL}, {GPIO_NUM_32, NULL, NULL}, 
    {GPIO_NUM_33, NULL, NULL}, {GPIO_NUM_34, NULL, NULL}, {GPIO_NUM_35, NULL, NULL}, {GPIO_NUM_36, NULL, NULL}, 
    {GPIO_NUM_37, NULL, NULL}, {GPIO_NUM_38, NULL, NULL}, {GPIO_NUM_39, NULL, NULL},
    #elif defined(CONFIG_IDF_TARGET_ESP32S2)
    {GPIO_NUM_21, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL},
    {GPIO_NUM_NC, NULL, NULL}, {GPIO_NUM_26, NULL, NULL}, {GPIO_NUM_27, NULL, NULL}, {GPIO_NUM_28, NULL, NULL},
    {GPIO_NUM_29, NULL, NULL}, {GPIO_NUM_30, NULL, NULL}, {GPIO_NUM_31, NULL, NULL}, {GPIO_NUM_32, NULL, NULL}, 
    {GPIO_NUM_33, NULL, NULL}, {GPIO_NUM_34, NULL, NULL}, {GPIO_NUM_35, NULL, NULL}, {GPIO_NUM_36, NULL, NULL}, 
    {GPIO_NUM_37, NULL, NULL}, {GPIO_NUM_38, NULL, NULL}, {GPIO_NUM_39, NULL, NULL}, {GPIO_NUM_40, NULL, NULL}, 
    {GPIO_NUM_41, NULL, NULL}, {GPIO_NUM_42, NULL, NULL}, {GPIO_NUM_43, NULL, NULL},
    {GPIO_NUM_44, NULL, NULL}, {GPIO_NUM_45, NULL, NULL}, {GPIO_NUM_46, NULL, NULL}, 
    #elif defined(CONFIG_IDF_TARGET_ESP32S3)
    {GPIO_NUM_21, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL}, {GPIO_NUM_NC, NULL, NULL},
    {GPIO_NUM_NC, NULL, NULL}, {GPIO_NUM_26, NULL, NULL}, {GPIO_NUM_27, NULL, NULL}, {GPIO_NUM_28, NULL, NULL},
    {GPIO_NUM_29, NULL, NULL}, {GPIO_NUM_30, NULL, NULL}, {GPIO_NUM_31, NULL, NULL}, {GPIO_NUM_32, NULL, NULL}, 
    {GPIO_NUM_33, NULL, NULL}, {GPIO_NUM_34, NULL, NULL}, {GPIO_NUM_35, NULL, NULL}, {GPIO_NUM_36, NULL, NULL}, 
    {GPIO_NUM_37, NULL, NULL}, {GPIO_NUM_38, NULL, NULL}, {GPIO_NUM_39, NULL, NULL}, {GPIO_NUM_40, NULL, NULL}, 
    {GPIO_NUM_41, NULL, NULL}, {GPIO_NUM_42, NULL, NULL}, {GPIO_NUM_43, NULL, NULL}, {GPIO_NUM_44, NULL, NULL}, 
    {GPIO_NUM_45, NULL, NULL}, {GPIO_NUM_46, NULL, NULL}, {GPIO_NUM_47, NULL, NULL}, {GPIO_NUM_48, NULL, NULL},
    #endif
};

/**
 * @brief Initialize a GPIO pin according to Tuya GPIO configuration
 * 
 * This function maps all Tuya GPIO modes to ESP32 native GPIO configuration.
 * Supports all modes defined in TUYA_GPIO_MODE_E.
 * 
 * @param pin_id Tuya GPIO pin identifier
 * @param cfg Pointer to GPIO configuration structure
 * @return OPERATE_RET OPRT_OK on success, error code on failure
 */
OPERATE_RET tkl_gpio_init(TUYA_GPIO_NUM_E pin_id, const TUYA_GPIO_BASE_CFG_T *cfg)
{
    esp_err_t ret;
    int gpio_num;
    gpio_mode_t gpio_mode;
    gpio_pullup_t pull_up = GPIO_PULLUP_DISABLE;
    gpio_pulldown_t pull_down = GPIO_PULLDOWN_DISABLE;

    if (NULL == cfg) {
        return OPRT_INVALID_PARM;
    }

    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);
    gpio_num = pinmap[pin_id].gpio;

    // Reset pin to default state
    gpio_reset_pin(gpio_num);

    // Map Tuya configuration to ESP32 GPIO configuration
    if (cfg->direct == TUYA_GPIO_INPUT) {
        // Handle input modes
        gpio_mode = GPIO_MODE_INPUT;
        
        switch (cfg->mode) {
            case TUYA_GPIO_PULLUP:          // 0 - Input with pull-up
                pull_up = GPIO_PULLUP_ENABLE;
                pull_down = GPIO_PULLDOWN_DISABLE;
                break;
                
            case TUYA_GPIO_PULLDOWN:        // 1 - Input with pull-down
                pull_up = GPIO_PULLUP_DISABLE;
                pull_down = GPIO_PULLDOWN_ENABLE;
                break;
                
            case TUYA_GPIO_HIGH_IMPEDANCE:  // 2 - High-impedance input
            case TUYA_GPIO_FLOATING:        // 3 - Floating input
            default:
                // No pull-up or pull-down for high-impedance/floating
                pull_up = GPIO_PULLUP_DISABLE;
                pull_down = GPIO_PULLDOWN_DISABLE;
                break;
        }
    } 
    else if (cfg->direct == TUYA_GPIO_OUTPUT) {
        // Handle output modes
        switch (cfg->mode) {
            case TUYA_GPIO_PUSH_PULL:           // 4 - Standard push-pull output
                gpio_mode = GPIO_MODE_OUTPUT;
                pull_up = GPIO_PULLUP_DISABLE;
                pull_down = GPIO_PULLDOWN_DISABLE;
                break;
                
            case TUYA_GPIO_OPENDRAIN:           // 5 - Open-drain without internal pull-up
                gpio_mode = GPIO_MODE_OUTPUT_OD;
                pull_up = GPIO_PULLUP_DISABLE;
                pull_down = GPIO_PULLDOWN_DISABLE;
                break;
                
            case TUYA_GPIO_OPENDRAIN_PULLUP:    // 6 - Open-drain with internal pull-up
                gpio_mode = GPIO_MODE_INPUT_OUTPUT_OD;
                pull_up = GPIO_PULLUP_ENABLE;
                pull_down = GPIO_PULLDOWN_DISABLE;
                break;
                
            default:
                // Default to push-pull if invalid mode specified for output
                gpio_mode = GPIO_MODE_OUTPUT;
                pull_up = GPIO_PULLUP_DISABLE;
                pull_down = GPIO_PULLDOWN_DISABLE;
                ESP_LOGW(DBG_TAG, "%s: Invalid output mode %d for pin %d, defaulting to PUSH_PULL", 
                         __func__, cfg->mode, gpio_num);
                break;
        }
    } 
    else {
        // Invalid direction
        ESP_LOGE(DBG_TAG, "%s: Invalid GPIO direction %d for pin %d", 
                 __func__, cfg->direct, gpio_num);
        return OPRT_NOT_SUPPORTED;
    }

    // Configure GPIO using ESP32's unified gpio_config API
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << gpio_num),
        .mode = gpio_mode,
        .pull_up_en = pull_up,
        .pull_down_en = pull_down,
        .intr_type = GPIO_INTR_DISABLE  // Interrupts handled separately
    };
    
    ret = gpio_config(&io_conf);
    if (ret != ESP_OK) {
        ESP_LOGE(DBG_TAG, "%s: gpio_config failed for pin %d: %s (0x%x)", 
                 __func__, gpio_num, esp_err_to_name(ret), ret);
        
        // Map ESP32 error to Tuya error code
        switch (ret) {
            case ESP_ERR_INVALID_ARG:
                return OPRT_INVALID_PARM;
            case ESP_ERR_NOT_SUPPORTED:
                return OPRT_NOT_SUPPORTED;
            default:
                return OPRT_COM_ERROR;
        }
    }

    // Set initial output level ONLY AFTER pin is properly configured
    if (cfg->direct == TUYA_GPIO_OUTPUT) {
        gpio_set_level(gpio_num, cfg->level);
    }

    // Log successful configuration for debugging
    ESP_LOGD(DBG_TAG, "%s: GPIO %d configured as %s mode %d (level: %d)", 
             __func__, gpio_num,
             (cfg->direct == TUYA_GPIO_INPUT) ? "INPUT" : "OUTPUT",
             cfg->mode, cfg->level);

    return OPRT_OK;
}

OPERATE_RET tkl_gpio_write(TUYA_GPIO_NUM_E pin_id, TUYA_GPIO_LEVEL_E level)
{
    int gpio_num;

    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);
    gpio_num = pinmap[pin_id].gpio;
    gpio_set_level(gpio_num, level);

    return OPRT_OK;    
}

OPERATE_RET tkl_gpio_read(TUYA_GPIO_NUM_E pin_id, TUYA_GPIO_LEVEL_E *level)
{
    int gpio_num;

    if (level == NULL) {
        return OPRT_INVALID_PARM;
    }
    
    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);
    gpio_num = pinmap[pin_id].gpio;
    
    *level = gpio_get_level(gpio_num);
    return OPRT_OK;
}

/**
 * @brief gpio irq init
 * NOTE: call this API will not enable interrupt
 * 
 * @param[in] port: gpio port 
 * @param[in] cfg:  gpio irq config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_init(TUYA_GPIO_NUM_E pin_id, const TUYA_GPIO_IRQ_T *cfg)
{
    int gpio_num;
    gpio_int_type_t trigger;
    esp_err_t ret;

    if (NULL == cfg) {
        return OPRT_INVALID_PARM;
    }

    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);

    pinmap[pin_id].cb = cfg->cb;
    pinmap[pin_id].args = cfg->arg;
    gpio_num = pinmap[pin_id].gpio;	

    switch (cfg->mode) {
    case TUYA_GPIO_IRQ_RISE:
        trigger = GPIO_INTR_POSEDGE; 
        break;
    case TUYA_GPIO_IRQ_FALL:
        trigger = GPIO_INTR_NEGEDGE; 
        break;
    case TUYA_GPIO_IRQ_RISE_FALL:
        trigger = GPIO_INTR_ANYEDGE;
        break;    
    case TUYA_GPIO_IRQ_LOW:
        trigger = GPIO_INTR_LOW_LEVEL; 
        break;
    case TUYA_GPIO_IRQ_HIGH:
        trigger = GPIO_INTR_HIGH_LEVEL; 
        break;
    default: 
        return OPRT_NOT_SUPPORTED;
    }

    ret = gpio_set_intr_type(gpio_num, trigger);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_set_intr_type failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }

    // Configure as input (required for interrupts)
    ret = gpio_set_direction(gpio_num, GPIO_MODE_INPUT);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_set_direction failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }

    // Install ISR service if not already installed
    ret = gpio_install_isr_service(0);
    if (ret != ESP_OK && ret != ESP_ERR_INVALID_STATE) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_install_isr_service failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }

    // Add ISR handler
    ret = gpio_isr_handler_add(gpio_num, pinmap[pin_id].cb, pinmap[pin_id].args);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_isr_handler_add failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}

/**
 * @brief gpio irq enable
 * 
 * @param[in] port: gpio port 
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_enable(TUYA_GPIO_NUM_E pin_id)
{
    int gpio_num;
    esp_err_t ret;

    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);
    gpio_num = pinmap[pin_id].gpio;
    
    ret = gpio_intr_enable(gpio_num);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_intr_enable failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}

/**
 * @brief gpio irq disable
 * 
 * @param[in] port: gpio port 
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_disable(TUYA_GPIO_NUM_E pin_id)
{
    int gpio_num;
    esp_err_t ret;

    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);
    gpio_num = pinmap[pin_id].gpio;
    
    ret = gpio_intr_disable(gpio_num);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_intr_disable failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }
    
    return OPRT_OK;    
}

/**
 * @brief Deinitialize a GPIO pin
 * 
 * @param pin_id Tuya GPIO pin identifier
 * @return OPERATE_RET OPRT_OK on success, error code on failure
 */
OPERATE_RET tkl_gpio_deinit(TUYA_GPIO_NUM_E pin_id)
{
    int gpio_num;
    esp_err_t ret;
    
    PIN_DEV_CHECK_ERROR_RETURN(pin_id, OPRT_INVALID_PARM);
    gpio_num = pinmap[pin_id].gpio;

    // Remove ISR handler if it exists
    ret = gpio_isr_handler_remove(gpio_num);
    if (ret != ESP_OK && ret != ESP_ERR_INVALID_ARG) {
        ESP_LOGE(DBG_TAG, "%s: call gpio_isr_handler_remove failed(ret=%d)", __func__, ret);
    }

    // Reset pin to default state
    gpio_reset_pin(gpio_num);
    
    // Clear callback pointers
    pinmap[pin_id].cb = NULL;
    pinmap[pin_id].args = NULL;
    
    return OPRT_OK;
}
