/**
 * @file tkl_pwm.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */
#include "freertos/FreeRTOS.h"
#include "esp_err.h"
#include "esp_log.h"

#include "driver/gpio.h"
#include "hal/gpio_types.h"

#include "hal/ledc_types.h"
#include "driver/ledc.h"

#include "tuya_error_code.h"
#include "tuya_cloud_types.h"

#include "tkl_system.h"
#include "tkl_memory.h"
#include "tkl_pwm.h"
#include "tkl_output.h"

#define PWM_DEV_NUM 6

typedef struct {
    unsigned int gpio_num;
    unsigned int pwm_channel_num;
    unsigned int pwm_used_gpio;
    unsigned char  used;
} PWM_CFG_T;

typedef struct {
    TUYA_GPIO_NUM_E pin;
    ledc_channel_t  channel;
} SR_PWM_GPIO_T;

static SR_PWM_GPIO_T sg_pwm_gpio_map[] = {
    {TUYA_IO_PIN_18, LEDC_CHANNEL_0},
    {TUYA_IO_PIN_19, LEDC_CHANNEL_1},
    {TUYA_IO_PIN_22, LEDC_CHANNEL_2},
    {TUYA_IO_PIN_23, LEDC_CHANNEL_3},
    {TUYA_IO_PIN_25, LEDC_CHANNEL_4},
    {TUYA_IO_PIN_26, LEDC_CHANNEL_5},
};

#if 0
PWM_CFG_T pwm_cfg_list[PWM_DEV_NUM] = {
    {GPIO_NUM_22, TUYA_PWM_NUM_0, PWM_CH0_USED_GPIO22, 1},
    {GPIO_NUM_23, TUYA_PWM_NUM_1, PWM_CH1_USED_GPIO23, 1},
    {GPIO_NUM_24, TUYA_PWM_NUM_2, PWM_CH2_USED_GPIO24, 1},
    {GPIO_NUM_25, TUYA_PWM_NUM_3, PWM_CH3_USED_GPIO25, 1},
    {GPIO_NUM_4,  TUYA_PWM_NUM_4, PWM_CH4_USED_GPIO4,  0},
    {GPIO_NUM_14, TUYA_PWM_NUM_4, PWM_CH4_USED_GPIO14, 1},
    {GPIO_NUM_15, TUYA_PWM_NUM_5, PWM_CH5_USED_GPIO15, 1}
};

TUYA_PWM_BASE_CFG_T g_pwm_info[DRV_PWM_CHN5 + 1];
int pwm_set_gpio_used(unsigned int pin)
{
    int i;
    unsigned int ch_num = TUYA_PWM_NUM_MAX;

    if (pin > GPIO_NUM_MAX)
        return OPRT_COM_ERROR;

    for (i = 0; i < PWM_DEV_NUM; i++) {
        if (pwm_cfg_list[i].gpio_num == pin) {
            ch_num = pwm_cfg_list[i].pwm_channel_num;
            break;
        }
    }

    if (ch_num >= TUYA_PWM_NUM_MAX) {
        return OPRT_COM_ERROR;
    }

    for (i = 0; i < PWM_DEV_NUM; i++) {
        if (pwm_cfg_list[i].pwm_channel_num == ch_num) {
            pwm_cfg_list[i].used = 0;
         }
    }
    
    for (i = 0; i < PWM_DEV_NUM; i++) {
        if (pwm_cfg_list[i].gpio_num == pin) {
            pwm_cfg_list[i].used = 1;
            break;
        }
    }
    
    return OPRT_OK;
}

int pwm_find_channel(unsigned int pin, unsigned int *ch_num, unsigned int *used_gpio)
{
    if ((ch_num == NULL) || (used_gpio == NULL))
    {
        return OPRT_OS_ADAPTER_COM_ERROR;
    }
    
    unsigned char i = 0;
    for(i = 0; i < PWM_DEV_NUM; i++) 
    {
        if(pwm_cfg_list[i].gpio_num == pin && pwm_cfg_list[i].used) 
        {
            *ch_num = pwm_cfg_list[i].pwm_channel_num;
            *used_gpio = pwm_cfg_list[i].pwm_used_gpio;
            break;
        }
    }

    if(i >= PWM_DEV_NUM){
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}

static int pwm_ch_find_gpio(unsigned int ch_num, unsigned int *used_gpio)
{
    if (used_gpio == NULL)
    {
        return OPRT_OS_ADAPTER_COM_ERROR;
    }
    
    unsigned char i = 0;
    for(i = 0; i < PWM_DEV_NUM; i++) 
    {
        if(pwm_cfg_list[i].pwm_channel_num == ch_num && pwm_cfg_list[i].used)
        {
            *used_gpio = pwm_cfg_list[i].pwm_used_gpio;
            break;
        }
    }

    if(i >= PWM_DEV_NUM){
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}
#endif

void __tkl_pwm_set_pin(TUYA_GPIO_NUM_E pin, TUYA_PWM_NUM_E channel)
{
    if (TUYA_PWM_NUM_MAX <= channel) {
        return;
    }

    int i;
    for (i = 0; i < sizeof(sg_pwm_gpio_map)/sizeof(SR_PWM_GPIO_T); i++) {
        if (sg_pwm_gpio_map[i].channel == (ledc_channel_t)channel) {
            sg_pwm_gpio_map[i].pin = pin;
            break;
        }
    }
    return;
}

/**
 * @brief pwm init
 * 
 * @param[in] port: pwm port
 * @param[in] cfg: pwm config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_init(TUYA_PWM_NUM_E ch_id, const TUYA_PWM_BASE_CFG_T *cfg)
{
    ledc_channel_config_t ledc_ch_config;
    ledc_timer_config_t ledc_time_config;

    uint32_t duty = cfg->duty;
    duty = duty * 4096 / 10000; // convert to 12 bit

    memset(&ledc_ch_config, 0, sizeof(ledc_channel_config_t));
    ledc_ch_config.gpio_num = sg_pwm_gpio_map[ch_id].pin;
    ledc_ch_config.speed_mode = LEDC_LOW_SPEED_MODE;
    ledc_ch_config.channel  = sg_pwm_gpio_map[ch_id].channel;
    ledc_ch_config.intr_type = LEDC_INTR_DISABLE;
    ledc_ch_config.timer_sel = LEDC_TIMER_0;
    ledc_ch_config.duty = duty;
    ledc_ch_config.hpoint = 0;

    memset(&ledc_time_config, 0, sizeof(ledc_timer_config_t));
    ledc_time_config.speed_mode = LEDC_LOW_SPEED_MODE;
    ledc_time_config.duty_resolution = LEDC_TIMER_12_BIT;
    ledc_time_config.timer_num = LEDC_TIMER_0;
    ledc_time_config.freq_hz = cfg->frequency;
    ledc_time_config.clk_cfg = 0;

    if (ledc_timer_config(&ledc_time_config) != ESP_OK) {
        return OPRT_COM_ERROR;
    }
    if (ledc_channel_config(&ledc_ch_config) != ESP_OK) {
        return OPRT_COM_ERROR;
    }
    return OPRT_OK;
}

OPERATE_RET tkl_pwm_start(TUYA_PWM_NUM_E ch_id)
{
    if (ledc_set_pin(sg_pwm_gpio_map[ch_id].pin, LEDC_LOW_SPEED_MODE, sg_pwm_gpio_map[ch_id].channel) != ESP_OK) {
        return OPRT_COM_ERROR;
    }
    
    return OPRT_OK;
}

OPERATE_RET tkl_pwm_stop(TUYA_PWM_NUM_E ch_id)
{
    // ledc_fade_stop(LEDC_LOW_SPEED_MODE, ch_id);
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief set pwm info
 * 
 * @param[in] port: pwm port
 * @param[in] info: pwm info
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_info_set(TUYA_PWM_NUM_E ch_id, const TUYA_PWM_BASE_CFG_T *info)
{
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief get pwm info
 * 
 * @param[in] port: pwm port
 * @param[out] info: pwm info
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_info_get(TUYA_PWM_NUM_E ch_id, TUYA_PWM_BASE_CFG_T *info)
{
    info->duty = ledc_get_duty(LEDC_LOW_SPEED_MODE, ch_id);
    info->frequency = ledc_get_freq(LEDC_LOW_SPEED_MODE, ch_id); /* timer */
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_pwm_deinit(TUYA_PWM_NUM_E ch_id)
{
     return OPRT_NOT_SUPPORTED;
}

/**
 * @brief multiple pwm channel start
 *
 * @param[in] ch_id: pwm channal id list
 * @param[in] num  : num of pwm channal to start
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_multichannel_start(TUYA_PWM_NUM_E *ch_id, uint8_t num)
{
    return OPRT_NOT_SUPPORTED;    
} 

/**
 * @brief multiple pwm channel stop
 *
 * @param[in] ch_id: pwm channal id list
 * @param[in] num  : num of pwm channal to stop
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_multichannel_stop(TUYA_PWM_NUM_E *ch_id, uint8_t num)
{
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief pwm duty set
 * 
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] duty:  pwm duty cycle
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_duty_set(TUYA_PWM_NUM_E ch_id, uint32_t duty)
{
    ledc_set_duty(LEDC_LOW_SPEED_MODE, ch_id, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, ch_id);
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief pwm frequency set
 * 
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] frequency: pwm frequency
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_frequency_set(TUYA_PWM_NUM_E ch_id, uint32_t frequency)
{
    ledc_set_freq(LEDC_LOW_SPEED_MODE, ch_id, frequency); /* timer */
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief pwm polarity set
 * 
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] polarity: pwm polarity
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_polarity_set(TUYA_PWM_NUM_E ch_id, TUYA_PWM_POLARITY_E polarity)
{
    return OPRT_NOT_SUPPORTED;
}
